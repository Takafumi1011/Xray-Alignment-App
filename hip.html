<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Precision Hip Finder V4.1</title>
    <style>
        body { margin: 0; background: #000; color: #fff; font-family: sans-serif; text-align: center; overflow: hidden; touch-action: none; }
        #canvas-container { position: relative; width: 100vw; height: 75vh; cursor: crosshair; background: #111; }
        canvas { display: block; }
        .ui { padding: 15px; background: #1a1a1a; border-bottom: 1px solid #333; }
        .guide { font-size: 13px; color: #34C759; margin-bottom: 8px; font-weight: bold; }
        .controls { padding: 10px; display: flex; justify-content: center; gap: 10px; }
        button { padding: 12px 20px; font-weight: bold; background: #007AFF; color: white; border: none; border-radius: 8px; font-size: 14px; }
        .reset-btn { background: #FF3B30; }
    </style>
</head>
<body>

<div class="ui">
    <div id="instruction" class="guide">1. 画像を読み込んでください</div>
    <input type="file" id="upload" accept="image/*" style="display:none">
    <button onclick="document.getElementById('upload').click()">画像読込</button>
    <button class="reset-btn" onclick="resetMarkers()">リセット</button>
</div>

<div id="canvas-container">
    <canvas id="canvas"></canvas>
</div>

<div class="controls">
    <div id="status-text" style="font-size: 12px; color: #aaa;">待機中...</div>
</div>

<script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    let img = new Image();
    let imgLoaded = false;
    let detectedPoints = []; // 検出した点を保存
    let step = 0; // 0:読込前, 1:右脚待ち, 2:左脚待ち

    document.getElementById('upload').addEventListener('change', (e) => {
        const file = e.target.files[0];
        const reader = new FileReader();
        reader.onload = (f) => {
            img.onload = () => {
                imgLoaded = true;
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight * 0.75;
                drawAll();
                setStep(1);
            };
            img.src = f.target.result;
        };
        reader.readAsDataURL(file);
    });

    function setStep(s) {
        step = s;
        const ins = document.getElementById('instruction');
        const st = document.getElementById('status-text');
        if(s===1) { ins.innerText = "2. 右大腿骨頭の中心付近をタップ"; st.innerText = "右脚待ち"; }
        if(s===2) { ins.innerText = "3. 左大腿骨頭の中心付近をタップ"; st.innerText = "左脚待ち"; }
        if(s===3) { ins.innerText = "完了！精度はどうですか？"; st.innerText = "全検知完了"; }
    }

    function resetMarkers() {
        detectedPoints = [];
        if(imgLoaded) { drawAll(); setStep(1); }
    }

    canvas.addEventListener('touchstart', (e) => {
        e.preventDefault();
        if (!imgLoaded || step > 2) return;
        const touch = e.touches[0];
        handleInput(touch.clientX, touch.clientY);
    }, {passive: false});

    canvas.addEventListener('mousedown', (e) => {
        if (!imgLoaded || step > 2) return;
        handleInput(e.clientX, e.clientY);
    });

    function handleInput(clientX, clientY) {
        const rect = canvas.getBoundingClientRect();
        const scale = Math.min(canvas.width / img.width, canvas.height / img.height);
        const offsetX = (canvas.width - img.width * scale) / 2;
        const offsetY = (canvas.height - img.height * scale) / 2;

        // 画像上の座標に変換
        const imgX = (clientX - rect.left - offsetX) / scale;
        const imgY = (clientY - rect.top - offsetY) / scale;

        // 精密化（スキャン）
        const refined = refineCenter(imgX, imgY);
        detectedPoints.push({ x: refined.x, y: refined.y, label: step === 1 ? "RH" : "LH" });
        
        drawAll();
        setStep(step + 1);
    }

    function refineCenter(tx, ty) {
        const scanSize = 60;
        const temp = document.createElement('canvas');
        temp.width = scanSize; temp.height = scanSize;
        const tCtx = temp.getContext('2d');
        tCtx.drawImage(img, tx - scanSize/2, ty - scanSize/2, scanSize, scanSize, 0, 0, scanSize, scanSize);
        const data = tCtx.getImageData(0,0,scanSize,scanSize).data;

        let weightedX = 0, weightedY = 0, totalWeight = 0, maxB = 0;
        for(let i=0; i<data.length; i+=4) {
            let b = data[i]+data[i+1]+data[i+2];
            if(b > maxB) maxB = b;
        }
        const threshold = maxB * 0.9;
        for(let y=0; y<scanSize; y++) {
            for(let x=0; x<scanSize; x++) {
                let i = (y * scanSize + x) * 4;
                if(data[i]+data[i+1]+data[i+2] > threshold) {
                    weightedX += x; weightedY += y; totalWeight++;
                }
            }
        }
        if(totalWeight === 0) return { x: tx, y: ty };
        return { x: tx - scanSize/2 + (weightedX / totalWeight), y: ty - scanSize/2 + (weightedY / totalWeight) };
    }

    function drawAll() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        const scale = Math.min(canvas.width / img.width, canvas.height / img.height);
        const offsetX = (canvas.width - img.width * scale) / 2;
        const offsetY = (canvas.height - img.height * scale) / 2;

        ctx.save();
        ctx.translate(offsetX, offsetY);
        ctx.scale(scale, scale);
        ctx.drawImage(img, 0, 0);

        detectedPoints.forEach(pt => {
            ctx.strokeStyle = "#00FF00"; ctx.lineWidth = 4 / scale;
            ctx.beginPath(); ctx.arc(pt.x, pt.y, 30 / scale, 0, Math.PI*2); ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(pt.x - 40/scale, pt.y); ctx.lineTo(pt.x + 40/scale, pt.y);
            ctx.moveTo(pt.x, pt.y - 40/scale); ctx.lineTo(pt.x, pt.y + 40/scale);
            ctx.stroke();
            ctx.fillStyle = "#00FF00"; ctx.font = `bold ${30/scale}px sans-serif`;
            ctx.fillText(pt.label, pt.x + 45/scale, pt.y - 45/scale);
        });
        ctx.restore();
    }
</script>
</body>
</html>
