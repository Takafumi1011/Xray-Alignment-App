<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Zoom & Precision Hip Finder V4.2</title>
    <style>
        body { margin: 0; background: #000; color: #fff; font-family: sans-serif; text-align: center; overflow: hidden; touch-action: none; }
        #canvas-container { position: relative; width: 100vw; height: 80vh; background: #111; }
        canvas { display: block; }
        .ui { padding: 10px; background: #1a1a1a; border-bottom: 1px solid #333; }
        .guide { font-size: 13px; color: #34C759; font-weight: bold; margin-bottom: 5px; }
        .controls { padding: 5px; display: flex; justify-content: center; gap: 10px; }
        button { padding: 10px 18px; font-weight: bold; background: #007AFF; color: white; border: none; border-radius: 8px; font-size: 13px; }
        .reset-btn { background: #FF3B30; }
    </style>
</head>
<body>

<div class="ui">
    <div id="instruction" class="guide">1. 画像を読み込んでください</div>
    <input type="file" id="upload" accept="image/*" style="display:none">
    <button onclick="document.getElementById('upload').click()">画像読込</button>
    <button class="reset-btn" onclick="resetMarkers()">リセット</button>
</div>

<div id="canvas-container">
    <canvas id="canvas"></canvas>
</div>

<div class="controls">
    <div id="status-text" style="font-size: 12px; color: #aaa;">ズーム・移動してからタップしてください</div>
</div>

<script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    let img = new Image();
    let imgLoaded = false;
    let detectedPoints = [];
    let step = 0; 

    // ズーム・移動用変数
    let scale = 1, offsetX = 0, offsetY = 0;
    let lastDist = 0, lastX = 0, lastY = 0;
    let isDragging = false;
    let moveThreshold = 5; // タップか移動かを判定する閾値
    let startX = 0, startY = 0;

    document.getElementById('upload').addEventListener('change', (e) => {
        const file = e.target.files[0];
        const reader = new FileReader();
        reader.onload = (f) => {
            img.onload = () => {
                imgLoaded = true;
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight * 0.8;
                scale = Math.min(canvas.width / img.width, canvas.height / img.height);
                offsetX = (canvas.width - img.width * scale) / 2;
                offsetY = (canvas.height - img.height * scale) / 2;
                drawAll();
                setStep(1);
            };
            img.src = f.target.result;
        };
        reader.readAsDataURL(file);
    });

    function setStep(s) {
        step = s;
        const ins = document.getElementById('instruction');
        if(s===1) ins.innerText = "2. 右大腿骨頭をズームしてタップ";
        if(s===2) ins.innerText = "3. 左大腿骨頭をズームしてタップ";
        if(s>=3) ins.innerText = "完了！リセットでやり直し";
    }

    function resetMarkers() {
        detectedPoints = [];
        if(imgLoaded) { drawAll(); setStep(1); }
    }

    // タッチイベント処理
    canvas.addEventListener('touchstart', e => {
        e.preventDefault();
        if (e.touches.length === 2) {
            lastDist = Math.hypot(e.touches[0].pageX - e.touches[1].pageX, e.touches[0].pageY - e.touches[1].pageY);
        } else {
            const t = e.touches[0];
            lastX = t.clientX; lastY = t.clientY;
            startX = t.clientX; startY = t.clientY;
            isDragging = false;
        }
    }, {passive: false});

    canvas.addEventListener('touchmove', e => {
        e.preventDefault();
        if (e.touches.length === 2) {
            const dist = Math.hypot(e.touches[0].pageX - e.touches[1].pageX, e.touches[0].pageY - e.touches[1].pageY);
            const zoom = dist / lastDist;
            const midX = (e.touches[0].pageX + e.touches[1].pageX) / 2;
            const midY = (e.touches[0].pageY + e.touches[1].pageY) / 2;
            offsetX = midX - (midX - offsetX) * zoom;
            offsetY = midY - (midY - offsetY) * zoom;
            scale *= zoom;
            lastDist = dist;
        } else {
            const t = e.touches[0];
            const dx = t.clientX - lastX;
            const dy = t.clientY - lastY;
            if (Math.hypot(t.clientX - startX, t.clientY - startY) > moveThreshold) {
                isDragging = true;
                offsetX += dx;
                offsetY += dy;
            }
            lastX = t.clientX; lastY = t.clientY;
        }
        drawAll();
    }, {passive: false});

    canvas.addEventListener('touchend', e => {
        if (!isDragging && imgLoaded && step <= 2) {
            handleInput(startX, startY);
        }
    });

    function handleInput(clientX, clientY) {
        const rect = canvas.getBoundingClientRect();
        // 表示座標を画像座標に逆変換
        const imgX = (clientX - rect.left - offsetX) / scale;
        const imgY = (clientY - rect.top - offsetY) / scale;

        const refined = refineCenter(imgX, imgY);
        detectedPoints.push({ x: refined.x, y: refined.y, label: step === 1 ? "RH" : "LH" });
        
        drawAll();
        setStep(step + 1);
    }

    function refineCenter(tx, ty) {
        const scanSize = 80; // スキャン範囲を少し拡大
        const temp = document.createElement('canvas');
        temp.width = scanSize; temp.height = scanSize;
        const tCtx = temp.getContext('2d');
        tCtx.drawImage(img, tx - scanSize/2, ty - scanSize/2, scanSize, scanSize, 0, 0, scanSize, scanSize);
        const data = tCtx.getImageData(0,0,scanSize,scanSize).data;

        let weightedX = 0, weightedY = 0, totalWeight = 0, maxB = 0;
        for(let i=0; i<data.length; i+=4) {
            let b = data[i]+data[i+1]+data[i+2];
            if(b > maxB) maxB = b;
        }
        const threshold = maxB * 0.9;
        for(let y=0; y<scanSize; y++) {
            for(let x=0; x<scanSize; x++) {
                let i = (y * scanSize + x) * 4;
                if(data[i]+data[i+1]+data[i+2] > threshold) {
                    weightedX += x; weightedY += y; totalWeight++;
                }
            }
        }
        if(totalWeight === 0) return { x: tx, y: ty };
        return { x: tx - scanSize/2 + (weightedX / totalWeight), y: ty - scanSize/2 + (weightedY / totalWeight) };
    }

    function drawAll() {
        ctx.setTransform(1, 0, 0, 1, 0, 0);
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        if(!imgLoaded) return;

        ctx.translate(offsetX, offsetY);
        ctx.scale(scale, scale);
        ctx.drawImage(img, 0, 0);

        detectedPoints.forEach(pt => {
            ctx.strokeStyle = "#00FF00"; ctx.lineWidth = 4 / scale;
            ctx.beginPath(); ctx.arc(pt.x, pt.y, 25 / scale, 0, Math.PI*2); ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(pt.x - 35/scale, pt.y); ctx.lineTo(pt.x + 35/scale, pt.y);
            ctx.moveTo(pt.x, pt.y - 35/scale); ctx.lineTo(pt.x, pt.y + 35/scale);
            ctx.stroke();
            ctx.fillStyle = "#00FF00"; ctx.font = `bold ${24/scale}px sans-serif`;
            ctx.fillText(pt.label, pt.x + 30/scale, pt.y - 30/scale);
        });
    }

    window.onresize = () => {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight * 0.8;
        drawAll();
    };
</script>
</body>
</html>
