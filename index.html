<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>LDFA Precision Verifier</title>
    <style>
        body { margin: 0; font-family: sans-serif; background: #000; color: #fff; overflow: hidden; touch-action: none; }
        #header { position: absolute; top: 0; width: 100%; background: rgba(0,0,0,0.9); z-index: 100; font-size: 14px; border-bottom: 1px solid #444; text-align: center; padding: 10px 0; }
        .val { color: #007AFF; font-weight: bold; font-size: 18px; margin: 0 15px; }
        #canvas-container { position: relative; width: 100vw; height: 100vh; }
        canvas { display: block; }
        .controls { position: absolute; bottom: 30px; left: 50%; transform: translateX(-50%); z-index: 100; display: flex; gap: 10px; }
        button { padding: 12px 20px; border-radius: 8px; border: none; background: #007AFF; color: #fff; font-weight: bold; }
    </style>
</head>
<body>

<div id="header">
    右 LDFA: <span id="r-ldfa" class="val">-</span>° 
    左 LDFA: <span id="l-ldfa" class="val">-</span>°
</div>

<div id="canvas-container">
    <canvas id="mainCanvas"></canvas>
</div>

<div class="controls">
    <input type="file" id="upload" accept="image/*" style="display:none">
    <button onclick="document.getElementById('upload').click()">画像を読み込む</button>
</div>

<script>
    const canvas = document.getElementById('mainCanvas');
    const ctx = canvas.getContext('2d');
    const upload = document.getElementById('upload');
    let img = new Image();
    let imgLoaded = false;
    let scale = 1, offsetX = 0, offsetY = 0;
    let points = []; 
    let activePoint = null;
    let lastDist = 0, lastX = 0, lastY = 0;
    const dragOffsetY = -45;

    function initPoints() {
        if (!imgLoaded) return;
        const w = img.width, h = img.height;
        points = [
            // 右大腿骨 (0-3)
            { x: w * 0.35, y: h * 0.2, label: 'RH' }, { x: w * 0.35, y: h * 0.5, label: 'RKf' },
            { x: w * 0.30, y: h * 0.51, label: 'RLF' }, { x: w * 0.40, y: h * 0.51, label: 'RMF' },
            // 左大腿骨 (4-7)
            { x: w * 0.65, y: h * 0.2, label: 'LH' }, { x: w * 0.65, y: h * 0.5, label: 'LKf' },
            { x: w * 0.70, y: h * 0.51, label: 'LLF' }, { x: w * 0.60, y: h * 0.51, label: 'LMF' }
        ];
    }

    upload.addEventListener('change', (e) => {
        const file = e.target.files[0];
        if(!file) return;
        const reader = new FileReader();
        reader.onload = (f) => {
            img.onload = () => {
                imgLoaded = true;
                scale = Math.min(window.innerWidth / img.width, window.innerHeight / img.height);
                offsetX = (window.innerWidth - img.width * scale) / 2;
                offsetY = (window.innerHeight - img.height * scale) / 2;
                initPoints(); draw();
            };
            img.src = f.target.result;
        };
        reader.readAsDataURL(file);
    });

    function draw() {
        ctx.setTransform(1, 0, 0, 1, 0, 0); ctx.clearRect(0, 0, canvas.width, canvas.height);
        if (!imgLoaded) return;
        ctx.translate(offsetX, offsetY); ctx.scale(scale, scale);
        ctx.drawImage(img, 0, 0);
        ctx.lineWidth = 3 / scale;
        
        [[0, 'r'], [4, 'l']].forEach(([o, side]) => {
            drawLine(points[o+0], points[o+1], '#FF3B30'); // 機能軸
            drawLine(points[o+2], points[o+3], '#FFCC00'); // 関節面
        });

        points.forEach(p => {
            ctx.beginPath(); ctx.arc(p.x, p.y, 8 / scale, 0, Math.PI*2);
            ctx.fillStyle = (p === activePoint) ? '#00FF00' : '#FF3B30';
            ctx.fill(); ctx.strokeStyle = "black"; ctx.lineWidth = 1/scale; ctx.stroke();
        });
        if (activePoint) drawLoupe();
        calculateLDFA();
    }

    function drawLine(p1, p2, color) { ctx.beginPath(); ctx.moveTo(p1.x, p1.y); ctx.lineTo(p2.x, p2.y); ctx.strokeStyle = color; ctx.stroke(); }

    function calculateLDFA() {
        const getRad = (p1, p2) => Math.atan2(p2.y - p1.y, p2.x - p1.x);
        const toDeg = (rad) => rad * 180 / Math.PI;
        const norm = (deg) => { while(deg > 180) deg -= 360; while(deg < -180) deg += 360; return deg; };

        const calc = (o, side) => {
            const axisF = getRad(points[o+0], points[o+1]); // 股関節 -> 膝
            const jointF = getRad(points[o+2], points[o+3]); // 外側 -> 内側
            
            // LDFAは外側(Lateral)の角
            // 右脚: 外側は左(LF.x < MF.x). 左脚: 外側は右(LF.x > MF.x)
            let diff = toDeg(axisF - jointF);
            let ldfa = (side === 'r') ? (90 + diff) : (90 - diff);
            document.getElementById(side+'-ldfa').innerText = Math.abs(ldfa).toFixed(1);
        };
        calc(0, 'r'); calc(4, 'l');
    }

    function drawLoupe() {
        const size = 200;
        const isRight = activePoint.label.startsWith('R');
        const screenY = activePoint.y * scale + offsetY;
        let lx = isRight ? window.innerWidth - size - 20 : 20;
        let ly = (screenY < 250) ? window.innerHeight - size - 100 : 80;

        ctx.save(); ctx.setTransform(1, 0, 0, 1, 0, 0); 
        ctx.beginPath(); ctx.arc(lx + size/2, ly + size/2, size/2, 0, Math.PI*2); ctx.clip();
        ctx.fillStyle = "#000"; ctx.fillRect(lx, ly, size, size);
        const zoom = 2.5; const sw = size/zoom/scale;
        ctx.drawImage(img, activePoint.x - sw/2, activePoint.y - sw/2, sw, sw, lx, ly, size, size);
        ctx.strokeStyle = "#00FF00"; ctx.lineWidth = 2;
        ctx.beginPath(); ctx.moveTo(lx+size/2, ly); ctx.lineTo(lx+size/2, ly+size); ctx.moveTo(lx, ly+size/2); ctx.lineTo(lx+size, ly+size/2); ctx.stroke();
        ctx.fillStyle = "rgba(0,0,0,0.8)"; ctx.fillRect(lx, ly + size - 35, size, 35);
        ctx.fillStyle = "#00FF00"; ctx.font = "bold 18px sans-serif"; ctx.textAlign = "center";
        ctx.fillText(activePoint.label, lx + size/2, ly + size - 10);
        ctx.restore();
        ctx.strokeStyle = "white"; ctx.lineWidth = 3; ctx.beginPath(); ctx.arc(lx+size/2, ly+size/2, size/2, 0, Math.PI*2); ctx.stroke();
    }

    canvas.addEventListener('touchstart', e => {
        e.preventDefault();
        if (e.touches.length === 2) { lastDist = Math.hypot(e.touches[0].pageX - e.touches[1].pageX, e.touches[0].pageY - e.touches[1].pageY); }
        else { const t = e.touches[0]; const wX = (t.clientX - offsetX) / scale, wY = (t.clientY - offsetY) / scale; activePoint = points.find(p => Math.hypot(p.x - wX, p.y - wY) < 40 / scale); lastX = t.clientX; lastY = t.clientY; }
    }, {passive: false});

    canvas.addEventListener('touchmove', e => {
        e.preventDefault();
        if (e.touches.length === 2) { const dist = Math.hypot(e.touches[0].pageX - e.touches[1].pageX, e.touches[0].pageY - e.touches[1].pageY); const z = dist / lastDist; const mx = (e.touches[0].pageX + e.touches[1].pageX) / 2, my = (e.touches[0].pageY + e.touches[1].pageY) / 2; offsetX = mx - (mx - offsetX) * z; offsetY = my - (my - offsetY) * z; scale *= z; lastDist = dist; }
        else if (activePoint) { const t = e.touches[0]; activePoint.x = (t.clientX - offsetX) / scale; activePoint.y = (t.clientY + dragOffsetY - offsetY) / scale; }
        else { const t = e.touches[0]; offsetX += (t.clientX - lastX); offsetY += (t.clientY - lastY); lastX = t.clientX; lastY = t.clientY; }
        draw();
    }, {passive: false});

    canvas.addEventListener('touchend', () => { activePoint = null; draw(); });
    window.onload = () => { canvas.width = window.innerWidth; canvas.height = window.innerHeight; };
</script>
</body>
</html>
