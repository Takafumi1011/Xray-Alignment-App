<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>LDFA Precision Test</title>
    <style>
        body { margin: 0; font-family: sans-serif; background: #000; color: #fff; overflow: hidden; touch-action: none; }
        #header { position: absolute; top: 0; width: 100%; background: rgba(0,0,0,0.9); z-index: 100; font-size: 16px; border-bottom: 1px solid #444; text-align: center; padding: 15px 0; }
        .val { color: #007AFF; font-weight: bold; font-size: 20px; margin: 0 10px; }
        #canvas-container { position: relative; width: 100vw; height: 100vh; }
        canvas { display: block; }
        .controls { position: absolute; bottom: 30px; left: 50%; transform: translateX(-50%); z-index: 100; }
        button { padding: 12px 24px; border-radius: 10px; border: none; background: #007AFF; color: #fff; font-weight: bold; font-size: 14px; }
    </style>
</head>
<body>

<div id="header">
    右 LDFA: <span id="r-ldfa" class="val">-</span>° 
    左 LDFA: <span id="l-ldfa" class="val">-</span>°
</div>

<div id="canvas-container">
    <canvas id="mainCanvas"></canvas>
</div>

<div class="controls">
    <input type="file" id="upload" accept="image/*" style="display:none">
    <button onclick="document.getElementById('upload').click()">画像を読み込む</button>
</div>

<script>
    const canvas = document.getElementById('mainCanvas');
    const ctx = canvas.getContext('2d');
    const upload = document.getElementById('upload');
    let img = new Image();
    let imgLoaded = false;
    let scale = 1, offsetX = 0, offsetY = 0;
    let lastDist = 0, lastX = 0, lastY = 0;
    const dragOffsetY = -45;

    // 検証用4点（左右計8点）
    let points = [
        { x: 100, y: 100, label: 'RH', side: 'r' }, { x: 100, y: 300, label: 'RKf', side: 'r' },
        { x: 50, y: 310, label: 'RLF', side: 'r' }, { x: 150, y: 310, label: 'RMF', side: 'r' },
        { x: 300, y: 100, label: 'LH', side: 'l' }, { x: 300, y: 300, label: 'LKf', side: 'l' },
        { x: 350, y: 310, label: 'LLF', side: 'l' }, { x: 250, y: 310, label: 'LMF', side: 'l' }
    ];
    let activePoint = null;

    upload.addEventListener('change', (e) => {
        const file = e.target.files[0];
        if(!file) return;
        const reader = new FileReader();
        reader.onload = (f) => {
            img.onload = () => {
                imgLoaded = true;
                const fitScale = Math.min(window.innerWidth / img.width, window.innerHeight / img.height);
                scale = fitScale;
                offsetX = (window.innerWidth - img.width * scale) / 2;
                offsetY = (window.innerHeight - img.height * scale) / 2;
                // 画像に合わせて点を中央に配置
                resetPointsToCenter();
                draw();
            };
            img.src = f.target.result;
        };
        reader.readAsDataURL(file);
    });

    function resetPointsToCenter() {
        const w = img.width, h = img.height;
        points[0].x = w*0.35; points[0].y = h*0.2;  // RH
        points[1].x = w*0.35; points[1].y = h*0.5;  // RKf
        points[2].x = w*0.30; points[2].y = h*0.52; // RLF
        points[3].x = w*0.40; points[3].y = h*0.52; // RMF
        points[4].x = w*0.65; points[4].y = h*0.2;  // LH
        points[5].x = w*0.65; points[5].y = h*0.5;  // LKf
        points[6].x = w*0.70; points[6].y = h*0.52; // LLF
        points[7].x = w*0.60; points[7].y = h*0.52; // LMF
    }

    function draw() {
        ctx.setTransform(1, 0, 0, 1, 0, 0);
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        ctx.translate(offsetX, offsetY);
        ctx.scale(scale, scale);

        if (imgLoaded) ctx.drawImage(img, 0, 0);

        // 線を描画
        ctx.lineWidth = 3 / scale;
        for(let i=0; i<8; i+=4) {
            drawLine(points[i], points[i+1], '#FF3B30'); // 機能軸
            drawLine(points[i+2], points[i+3], '#FFCC00'); // 関節面
        }

        // 点を描画
        points.forEach(p => {
            ctx.beginPath();
            ctx.arc(p.x, p.y, 10 / scale, 0, Math.PI * 2);
            ctx.fillStyle = (p === activePoint) ? '#00FF00' : '#FF3B30';
            ctx.fill();
            ctx.strokeStyle = "white"; ctx.lineWidth = 1/scale; ctx.stroke();
            
            ctx.fillStyle = "white";
            ctx.font = `${14/scale}px sans-serif`;
            ctx.fillText(p.label, p.x + 12/scale, p.y + 12/scale);
        });

        if (activePoint) drawLoupe();
        calculateLDFA();
    }

    function drawLine(p1, p2, color) {
        ctx.beginPath(); ctx.moveTo(p1.x, p1.y); ctx.lineTo(p2.x, p2.y);
        ctx.strokeStyle = color; ctx.stroke();
    }

    function calculateLDFA() {
        const getAngle = (p1, p2, p3) => {
            // p1: 膝中心, p2: 股関節, p3: 外側顆
            const v1 = { x: p2.x - p1.x, y: p2.y - p1.y };
            const v2 = { x: p3.x - p1.x, y: p3.y - p1.y };
            const dot = v1.x * v2.x + v1.y * v2.y;
            const mag1 = Math.sqrt(v1.x * v1.x + v1.y * v1.y);
            const mag2 = Math.sqrt(v2.x * v2.x + v2.y * v2.y);
            return Math.acos(dot / (mag1 * mag2)) * 180 / Math.PI;
        };

        const rLDFA = getAngle(points[1], points[0], points[2]);
        const lLDFA = getAngle(points[5], points[4], points[6]);

        document.getElementById('r-ldfa').innerText = isNaN(rLDFA) ? "-" : rLDFA.toFixed(1);
        document.getElementById('l-ldfa').innerText = isNaN(lLDFA) ? "-" : lLDFA.toFixed(1);
    }

    function drawLoupe() {
        const size = 180;
        const isRight = activePoint.side === 'r';
        let lx = isRight ? window.innerWidth - size - 20 : 20;
        let ly = 100;
        
        ctx.save();
        ctx.setTransform(1, 0, 0, 1, 0, 0);
        ctx.beginPath(); ctx.arc(lx + size/2, ly + size/2, size/2, 0, Math.PI*2); ctx.clip();
        ctx.fillStyle = "#000"; ctx.fillRect(lx, ly, size, size);
        
        const zoom = 2.5;
        const sw = size / zoom / scale;
        ctx.drawImage(img, activePoint.x - sw/2, activePoint.y - sw/2, sw, sw, lx, ly, size, size);
        
        ctx.strokeStyle = "#00FF00"; ctx.lineWidth = 2;
        ctx.beginPath(); ctx.moveTo(lx+size/2, ly); ctx.lineTo(lx+size/2, ly+size);
        ctx.moveTo(lx, ly+size/2); ctx.lineTo(lx+size, ly+size/2); ctx.stroke();
        ctx.restore();
        ctx.strokeStyle = "white"; ctx.lineWidth = 3; ctx.beginPath(); ctx.arc(lx+size/2, ly+size/2, size/2, 0, Math.PI*2); ctx.stroke();
    }

    // タッチイベント
    canvas.addEventListener('touchstart', e => {
        e.preventDefault();
        const t = e.touches[0];
        if (e.touches.length === 2) {
            lastDist = Math.hypot(e.touches[0].pageX - e.touches[1].pageX, e.touches[0].pageY - e.touches[1].pageY);
        } else {
            const worldX = (t.clientX - offsetX) / scale;
            const worldY = (t.clientY - offsetY) / scale;
            activePoint = points.find(p => Math.hypot(p.x - worldX, p.y - worldY) < 40 / scale);
            lastX = t.clientX; lastY = t.clientY;
        }
    }, {passive: false});

    canvas.addEventListener('touchmove', e => {
        e.preventDefault();
        if (e.touches.length === 2) {
            const dist = Math.hypot(e.touches[0].pageX - e.touches[1].pageX, e.touches[0].pageY - e.touches[1].pageY);
            const zoom = dist / lastDist;
            const midX = (e.touches[0].pageX + e.touches[1].pageX) / 2;
            const midY = (e.touches[0].pageY + e.touches[1].pageY) / 2;
            offsetX = midX - (midX - offsetX) * zoom;
            offsetY = midY - (midY - offsetY) * zoom;
            scale *= zoom;
            lastDist = dist;
        } else if (activePoint) {
            const t = e.touches[0];
            activePoint.x = (t.clientX - offsetX) / scale;
            activePoint.y = (t.clientY + dragOffsetY - offsetY) / scale;
        } else {
            offsetX += (e.touches[0].clientX - lastX);
            offsetY += (e.touches[0].clientY - lastY);
            lastX = e.touches[0].clientX;
            lastY = e.touches[0].clientY;
        }
        draw();
    }, {passive: false});

    canvas.addEventListener('touchend', () => { activePoint = null; draw(); });

    window.onload = () => {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        draw();
    };
</script>
</body>
</html>
