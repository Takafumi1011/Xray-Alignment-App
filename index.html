<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>X-ray Alignment Pro V4</title>
    <style>
        body { margin: 0; font-family: sans-serif; background: #000; color: #fff; overflow: hidden; touch-action: none; }
        #header { position: absolute; top: 0; width: 100%; background: rgba(0,0,0,0.9); z-index: 100; font-size: 10px; border-bottom: 1px solid #444; }
        .row { display: flex; justify-content: space-around; padding: 4px 0; border-bottom: 1px solid #222; }
        .val { color: #007AFF; font-weight: bold; font-size: 12px; }
        #canvas-container { position: relative; width: 100vw; height: 100vh; }
        canvas { display: block; }
        .controls { position: absolute; bottom: 25px; left: 50%; transform: translateX(-50%); z-index: 100; display: flex; gap: 8px; }
        button { padding: 10px 15px; border-radius: 8px; border: none; background: #007AFF; color: #fff; font-weight: bold; }
    </style>
</head>
<body>

<div id="header">
    <div class="row">
        <div>右 HKA: <span id="r-hka" class="val">-</span></div>
        <div>LDFA: <span id="r-ldfa" class="val">-</span></div>
        <div>MPTA: <span id="r-mpta" class="val">-</span></div>
        <div>JLCA: <span id="r-jlca" class="val">-</span></div>
        <div>JLOA: <span id="r-jloa" class="val">-</span></div>
    </div>
    <div class="row">
        <div>左 HKA: <span id="l-hka" class="val">-</span></div>
        <div>LDFA: <span id="l-ldfa" class="val">-</span></div>
        <div>MPTA: <span id="l-mpta" class="val">-</span></div>
        <div>JLCA: <span id="l-jlca" class="val">-</span></div>
        <div>JLOA: <span id="l-jloa" class="val">-</span></div>
    </div>
</div>

<div id="canvas-container">
    <canvas id="mainCanvas"></canvas>
</div>

<div class="controls">
    <input type="file" id="upload" accept="image/*" style="display:none">
    <button onclick="document.getElementById('upload').click()">画像読込</button>
</div>

<script>
    const canvas = document.getElementById('mainCanvas');
    const ctx = canvas.getContext('2d');
    const upload = document.getElementById('upload');
    let img = new Image();
    let imgLoaded = false;

    // 座標変換用
    let scale = 1, offsetX = 0, offsetY = 0;
    let lastDist = 0, lastX = 0, lastY = 0;
    
    // 参照点 (世界座標系：画像上のピクセル位置を想定)
    let points = [];
    let activePoint = null;

    function initPoints() {
        const w = 400, h = 800;
        points = [
            // 水平基準線 (16, 17)
            { x: 50, y: 700, label: 'G1', type: 'ref' }, { x: 350, y: 700, label: 'G2', type: 'ref' },
            // 右脚 (0-7)
            { x: 150, y: 100, label: 'RH' }, { x: 150, y: 400, label: 'RKf' },
            { x: 150, y: 430, label: 'RKt' }, { x: 150, y: 750, label: 'RA' },
            { x: 120, y: 410, label: 'RMF' }, { x: 180, y: 410, label: 'RLF' },
            { x: 120, y: 420, label: 'RMT' }, { x: 180, y: 420, label: 'RLT' },
            // 左脚 (8-15)
            { x: 250, y: 100, label: 'LH' }, { x: 250, y: 400, label: 'LKf' },
            { x: 250, y: 430, label: 'LKt' }, { x: 250, y: 750, label: 'LA' },
            { x: 220, y: 410, label: 'LMF' }, { x: 280, y: 410, label: 'LLF' },
            { x: 220, y: 420, label: 'LMT' }, { x: 280, y: 420, label: 'LLT' }
        ];
    }

    upload.addEventListener('change', (e) => {
        const file = e.target.files[0];
        const reader = new FileReader();
        reader.onload = (f) => {
            img.onload = () => {
                imgLoaded = true;
                scale = Math.min(window.innerWidth / img.width, window.innerHeight / img.height);
                offsetX = (window.innerWidth - img.width * scale) / 2;
                offsetY = (window.innerHeight - img.height * scale) / 2;
                draw();
            };
            img.src = f.target.result;
        };
        reader.readAsDataURL(file);
    });

    function draw() {
        ctx.setTransform(1,0,0,1,0,0);
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        ctx.translate(offsetX, offsetY);
        ctx.scale(scale, scale);

        if (imgLoaded) ctx.drawImage(img, 0, 0);

        // 補助線描画
        ctx.lineWidth = 2 / scale;
        // 水平基準線
        drawLine(points[0], points[1], 'white');
        
        // 脚の線
        [[2, 'r'], [10, 'l']].forEach(([o, side]) => {
            drawLine(points[o+0], points[o+1], '#FF3B30'); // Femur
            drawLine(points[o+2], points[o+3], '#5856D6'); // Tibia
            drawLine(points[o+4], points[o+5], '#FFCC00'); // F-Joint
            drawLine(points[o+6], points[o+7], '#34C759'); // T-Joint
        });

        points.forEach(p => {
            ctx.beginPath(); ctx.arc(p.x, p.y, 8 / scale, 0, Math.PI*2);
            ctx.fillStyle = (p === activePoint) ? '#00FF00' : (p.type === 'ref' ? 'white' : '#FF3B30');
            ctx.fill();
            ctx.strokeStyle = "black"; ctx.lineWidth = 1/scale; ctx.stroke();
        });

        calculateAll();
    }

    function drawLine(p1, p2, color) {
        ctx.beginPath(); ctx.moveTo(p1.x, p1.y); ctx.lineTo(p2.x, p2.y);
        ctx.strokeStyle = color; ctx.stroke();
    }

    function calculateAll() {
        const getA = (a, b) => Math.atan2(b.y - a.y, b.x - a.x) * 180 / Math.PI;
        const refA = getA(points[0], points[1]); // 水平基準線の角度

        const calc = (o, side) => {
            const fA = getA(points[o+0], points[o+1]); // Femur Axis
            const tA = getA(points[o+2], points[o+3]); // Tibia Axis
            const fJ = getA(points[o+4], points[o+5]); // Femur Joint Line
            const tJ = getA(points[o+6], points[o+7]); // Tibia Joint Line

            // mHKA: 0基準 (内反-, 外反+)
            let hka = (side === 'r') ? (tA - fA) : (fA - tA);
            document.getElementById(side+'-hka').innerText = hka.toFixed(1);

            // LDFA: 90基準 (内反>90, 外反<90)
            let ldfa = 90 + (fA - fJ);
            document.getElementById(side+'-ldfa').innerText = ldfa.toFixed(1);

            // MPTA: 90基準 (内反<90, 外反>90)
            let mpta = 90 + (tA - tJ); // 符号調整
            document.getElementById(side+'-mpta').innerText = mpta.toFixed(1);

            // JLCA: 0基準 (内側オープン+, 外側オープン-)
            let jlca = (side === 'r') ? (fJ - tJ) : (tJ - fJ);
            document.getElementById(side+'-jlca').innerText = jlca.toFixed(1);

            // JLOA: 水平線基準
            let jloa = (side === 'r') ? (fJ - refA) : (refA - fJ);
            document.getElementById(side+'-jloa').innerText = jloa.toFixed(1);
        };
        calc(2, 'r'); calc(10, 'l');
    }

    canvas.addEventListener('touchstart', e => {
        e.preventDefault();
        if (e.touches.length === 2) {
            lastDist = Math.hypot(e.touches[0].pageX - e.touches[1].pageX, e.touches[0].pageY - e.touches[1].pageY);
        } else {
            const t = e.touches[0];
            const worldX = (t.clientX - offsetX) / scale;
            const worldY = (t.clientY - offsetY) / scale;
            activePoint = points.find(p => Math.hypot(p.x - worldX, p.y - worldY) < 30 / scale);
            lastX = t.clientX; lastY = t.clientY;
        }
    }, {passive: false});

    canvas.addEventListener('touchmove', e => {
        e.preventDefault();
        if (e.touches.length === 2) {
            const dist = Math.hypot(e.touches[0].pageX - e.touches[1].pageX, e.touches[0].pageY - e.touches[1].pageY);
            const zoom = dist / lastDist;
            const midX = (e.touches[0].pageX + e.touches[1].pageX) / 2;
            const midY = (e.touches[0].pageY + e.touches[1].pageY) / 2;
            
            offsetX = midX - (midX - offsetX) * zoom;
            offsetY = midY - (midY - offsetY) * zoom;
            scale *= zoom;
            lastDist = dist;
        } else if (activePoint) {
            const t = e.touches[0];
            activePoint.x = (t.clientX - offsetX) / scale;
            activePoint.y = (t.clientY - offsetY) / scale;
        } else {
            const t = e.touches[0];
            offsetX += (t.clientX - lastX);
            offsetY += (t.clientY - lastY);
            lastX = t.clientX; lastY = t.clientY;
        }
        draw();
    }, {passive: false});

    canvas.addEventListener('touchend', () => { activePoint = null; });

    window.onload = () => {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        initPoints();
        draw();
    };
</script>
</body>
</html>
